#!/usr/bin/env node
// ═══════════════════════════════════════════════════════════════════════
// AEZAKMI Antidetect Browser Launcher v4.0.0
// Engine: Camoufox (native antidetect Firefox fork)
// Usage: node scripts/launch_playwright.cjs --payload=<base64-json>
// ═══════════════════════════════════════════════════════════════════════

const path = require('path');
const fs = require('fs');
const { spawn, execSync } = require('child_process');

// ─── PRODUCTION MODE ──────────────────────────────────────────────────
const isDev = fs.existsSync(path.join(__dirname, '..', 'node_modules'));
const log = isDev ? console.log.bind(console) : () => {};
const warn = isDev ? console.warn.bind(console) : () => {};
const error = console.error.bind(console);

// ─── PRODUCTION ERROR LOG ─────────────────────────────────────────────
const logFilePath = (() => {
  const localAppData = process.env.LOCALAPPDATA || '';
  if (localAppData) {
    const logDir = path.join(localAppData, 'AEZAKMI Pro', 'logs');
    try { fs.mkdirSync(logDir, { recursive: true }); } catch (e) {}
    return path.join(logDir, 'launcher.log');
  }
  return null;
})();

function logToFile(msg) {
  if (!logFilePath) return;
  try {
    const ts = new Date().toISOString();
    fs.appendFileSync(logFilePath, `[${ts}] ${msg}\n`);
  } catch (e) {}
}

process.on('uncaughtException', (err) => {
  const msg = `UNCAUGHT EXCEPTION: ${err.message}\n${err.stack}`;
  error(msg);
  logToFile(msg);
  process.exit(1);
});
process.on('unhandledRejection', (reason) => {
  const msg = `UNHANDLED REJECTION: ${reason}`;
  error(msg);
  logToFile(msg);
  process.exit(1);
});

// ─── PATH RESOLUTION ──────────────────────────────────────────────────
const scriptDir = __dirname;
const appDir = path.dirname(scriptDir);
const localAppData = process.env.LOCALAPPDATA || '';

log('[LAUNCHER] Скрипт:', scriptDir);
log('[LAUNCHER] Приложение:', appDir);

// ═══════════════════════════════════════════════════════════════════════
// PROXY EXTENSION (Firefox WebExtension for proxy routing & auth)
// Handles proxy inside the browser process — no external bridges needed.
// camoufox.exe is a launcher stub that exits immediately, so bridges
// would die before the browser can use them.
// ═══════════════════════════════════════════════════════════════════════

function setupProxyExtension(profileDir, proxyConfig) {
  // proxyConfig: { type: 'http'|'https'|'socks4'|'socks5', host, port, username, password }
  const extId = 'proxy-helper@aezakmi';
  const extDir = path.join(profileDir, 'extensions', extId);

  fs.mkdirSync(extDir, { recursive: true });

  // Map proxy type to Firefox proxy API type
  let ffType;
  if (proxyConfig.type === 'socks5') ffType = 'socks';
  else if (proxyConfig.type === 'socks4') ffType = 'socks4';
  else ffType = 'http';

  const manifest = {
    manifest_version: 2,
    name: 'AEZAKMI Proxy',
    version: '1.0',
    description: 'Proxy routing and authentication',
    permissions: [
      'proxy',
      'webRequest',
      'webRequestBlocking',
      '<all_urls>'
    ],
    background: { scripts: ['background.js'] },
    browser_specific_settings: {
      gecko: { id: extId, strict_min_version: '91.0' }
    }
  };

  const background = [
    '// Auto-generated by AEZAKMI Launcher',
    'const P = ' + JSON.stringify({
      type: ffType,
      host: proxyConfig.host,
      port: proxyConfig.port,
      user: proxyConfig.username || '',
      pass: proxyConfig.password || '',
      dns: proxyConfig.type.includes('socks'),
    }) + ';',
    '',
    '// Route ALL requests through the configured proxy',
    'browser.proxy.onRequest.addListener(',
    '  () => ({',
    '    type: P.type,',
    '    host: P.host,',
    '    port: P.port,',
    '    username: P.user || undefined,',
    '    password: P.pass || undefined,',
    '    proxyDNS: P.dns',
    '  }),',
    '  { urls: ["<all_urls>"] }',
    ');',
    '',
    '// Handle HTTP proxy authentication',
    'if (P.user && P.pass) {',
    '  browser.webRequest.onAuthRequired.addListener(',
    '    (d) => d.isProxy ? { authCredentials: { username: P.user, password: P.pass } } : {},',
    '    { urls: ["<all_urls>"] },',
    '    ["blocking"]',
    '  );',
    '}',
    '',
    'browser.proxy.onError.addListener((e) => console.error("[AEZAKMI Proxy] Error:", e.message));',
    'console.log("[AEZAKMI Proxy] Loaded:", P.type + "://" + P.host + ":" + P.port);',
  ].join('\n');

  fs.writeFileSync(path.join(extDir, 'manifest.json'), JSON.stringify(manifest, null, 2));
  fs.writeFileSync(path.join(extDir, 'background.js'), background);

  log('[CAMOUFOX] Прокси-расширение создано:', extDir);
  return extDir;
}

function removeProxyExtension(profileDir) {
  const extId = 'proxy-helper@aezakmi';
  const extDir = path.join(profileDir, 'extensions', extId);
  try {
    if (fs.existsSync(extDir)) {
      fs.rmSync(extDir, { recursive: true, force: true });
      log('[CAMOUFOX] Прокси-расширение удалено');
    }
  } catch (e) { /* extension might be locked by running browser */ }
}

// ═══════════════════════════════════════════════════════════════════════
// CAMOUFOX ENGINE — Native Antidetect Firefox Fork
// Based on https://github.com/daijro/camoufox (DonutBrowser approach)
// ═══════════════════════════════════════════════════════════════════════

const CAMOUFOX_VERSION = '135.0.1-beta.24';
const CAMOUFOX_ZIP_NAME = `camoufox-${CAMOUFOX_VERSION}-win.x86_64.zip`;
const CAMOUFOX_URL = `https://github.com/daijro/camoufox/releases/download/v${CAMOUFOX_VERSION}/${CAMOUFOX_ZIP_NAME}`;

function getCamoufoxDir() {
  const la = process.env.LOCALAPPDATA || '';
  if (la) return path.join(la, 'AEZAKMI Pro', 'camoufox');
  return path.join(appDir, 'camoufox');
}

function getCamoufoxExe() {
  return path.join(getCamoufoxDir(), 'camoufox.exe');
}

// ─── HTTPS download with redirect following ───────────────────────────
function httpsGet(url) {
  return new Promise((resolve, reject) => {
    const doRequest = (reqUrl, redirects) => {
      if (redirects > 10) return reject(new Error('Too many redirects'));
      const parsed = new URL(reqUrl);
      const mod = parsed.protocol === 'https:' ? https : http;
      const req = mod.get(reqUrl, { headers: { 'User-Agent': 'AEZAKMI/4.0' } }, (res) => {
        if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
          return doRequest(res.headers.location, redirects + 1);
        }
        if (res.statusCode !== 200) {
          return reject(new Error(`HTTP ${res.statusCode} for ${reqUrl}`));
        }
        resolve(res);
      });
      req.on('error', reject);
      req.setTimeout(600000, () => { req.destroy(); reject(new Error('Download timeout')); });
    };
    doRequest(url, 0);
  });
}

async function downloadFile(url, destPath) {
  log(`[CAMOUFOX] Скачивание: ${url}`);
  logToFile(`Downloading: ${url}`);
  const res = await httpsGet(url);
  const totalSize = parseInt(res.headers['content-length'] || '0');
  let downloaded = 0;
  let lastPct = -1;

  return new Promise((resolve, reject) => {
    const fileStream = fs.createWriteStream(destPath);
    res.on('data', (chunk) => {
      downloaded += chunk.length;
      if (totalSize > 0) {
        const pct = Math.floor(downloaded / totalSize * 100);
        if (pct !== lastPct && pct % 10 === 0) {
          log(`[CAMOUFOX] Прогресс: ${pct}% (${Math.floor(downloaded / 1024 / 1024)} MB)`);
          logToFile(`Download progress: ${pct}%`);
          lastPct = pct;
        }
      }
    });
    res.pipe(fileStream);
    fileStream.on('finish', () => {
      fileStream.close();
      log(`[CAMOUFOX] Скачано: ${Math.floor(downloaded / 1024 / 1024)} MB`);
      resolve();
    });
    fileStream.on('error', reject);
    res.on('error', reject);
  });
}

async function ensureCamoufoxInstalled() {
  const exe = getCamoufoxExe();
  if (fs.existsSync(exe)) {
    log('[CAMOUFOX] Бинарник найден:', exe);
    return;
  }

  log('[CAMOUFOX] Camoufox не найден, начинаем установку...');
  logToFile('Camoufox not found, starting installation');

  const camoufoxDir = getCamoufoxDir();
  fs.mkdirSync(camoufoxDir, { recursive: true });

  const zipPath = path.join(camoufoxDir, CAMOUFOX_ZIP_NAME);

  // Скачиваем zip с GitHub
  await downloadFile(CAMOUFOX_URL, zipPath);

  // Распаковываем через PowerShell
  log('[CAMOUFOX] Распаковка...');
  logToFile('Extracting Camoufox...');
  try {
    execSync(
      `powershell -NoProfile -Command "Expand-Archive -Path '${zipPath}' -DestinationPath '${camoufoxDir}' -Force"`,
      { timeout: 300000, stdio: isDev ? 'inherit' : 'pipe' }
    );
  } catch (e) {
    throw new Error(`Ошибка распаковки Camoufox: ${e.message}`);
  }

  // Удаляем zip
  try { fs.unlinkSync(zipPath); } catch (e) {}

  // Проверяем что exe появился
  if (!fs.existsSync(exe)) {
    // Может быть вложенная папка после распаковки
    const entries = fs.readdirSync(camoufoxDir);
    log('[CAMOUFOX] Содержимое после распаковки:', entries.join(', '));
    // Ищем camoufox.exe рекурсивно
    const found = findExecutable(camoufoxDir, 'camoufox.exe');
    if (found) {
      log('[CAMOUFOX] Найден exe в подпапке:', found);
      logToFile(`Found exe in subdirectory: ${found}`);
    } else {
      throw new Error(`camoufox.exe не найден после распаковки в ${camoufoxDir}. Файлы: ${entries.join(', ')}`);
    }
  }

  // Сохраняем версию
  fs.writeFileSync(
    path.join(camoufoxDir, 'version.json'),
    JSON.stringify({ version: CAMOUFOX_VERSION, installed: new Date().toISOString() })
  );

  log('[CAMOUFOX] Установлен успешно:', exe);
  logToFile('Camoufox installed successfully');
}

function findExecutable(dir, name) {
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isFile() && entry.name.toLowerCase() === name.toLowerCase()) {
        return fullPath;
      }
      if (entry.isDirectory()) {
        const found = findExecutable(fullPath, name);
        if (found) return found;
      }
    }
  } catch (e) {}
  return null;
}

// ─── FINGERPRINT CONFIG GENERATOR ─────────────────────────────────────
// Generates a realistic Firefox fingerprint for Camoufox
// (based on DonutBrowser's browserforge approach)

function getWindowsFonts() {
  return [
    'Arial', 'Arial Black', 'Calibri', 'Cambria', 'Cambria Math', 'Candara',
    'Comic Sans MS', 'Consolas', 'Constantia', 'Corbel', 'Courier New',
    'Ebrima', 'Franklin Gothic Medium', 'Gabriola', 'Gadugi', 'Georgia',
    'Impact', 'Ink Free', 'Javanese Text', 'Leelawadee UI', 'Lucida Console',
    'Lucida Sans Unicode', 'Malgun Gothic', 'Microsoft Himalaya', 'Microsoft JhengHei',
    'Microsoft New Tai Lue', 'Microsoft PhagsPa', 'Microsoft Sans Serif',
    'Microsoft Tai Le', 'Microsoft YaHei', 'Microsoft Yi Baiti', 'MingLiU-ExtB',
    'Mongolian Baiti', 'MV Boli', 'Myanmar Text', 'Nirmala UI', 'Palatino Linotype',
    'Segoe MDL2 Assets', 'Segoe Print', 'Segoe Script', 'Segoe UI',
    'Segoe UI Historic', 'Segoe UI Emoji', 'Segoe UI Symbol',
    'SimSun', 'Sitka Banner', 'Sitka Display', 'Sitka Heading', 'Sitka Small',
    'Sitka Subheading', 'Sitka Text', 'Sylfaen', 'Symbol', 'Tahoma',
    'Times New Roman', 'Trebuchet MS', 'Verdana', 'Webdings', 'Wingdings',
    'Yu Gothic'
  ];
}

function getMacFonts() {
  return [
    'American Typewriter', 'Andale Mono', 'Arial', 'Arial Black', 'Arial Narrow',
    'Arial Rounded MT Bold', 'Avenir', 'Avenir Next', 'Avenir Next Condensed',
    'Baskerville', 'Big Caslon', 'Bodoni 72', 'Bodoni 72 Oldstyle',
    'Bodoni 72 Smallcaps', 'Bradley Hand', 'Brush Script MT', 'Chalkboard',
    'Chalkboard SE', 'Chalkduster', 'Charter', 'Cochin', 'Comic Sans MS',
    'Copperplate', 'Courier', 'Courier New', 'DIN Alternate', 'DIN Condensed',
    'Didot', 'Futura', 'Geneva', 'Georgia', 'Gill Sans', 'Helvetica',
    'Helvetica Neue', 'Herculanum', 'Hoefler Text', 'Impact', 'Lucida Grande',
    'Luminari', 'Marker Felt', 'Menlo', 'Monaco', 'Noteworthy', 'Optima',
    'Palatino', 'Papyrus', 'Phosphate', 'Rockwell', 'SF Pro', 'SF Pro Display',
    'SF Pro Rounded', 'SF Pro Text', 'Savoye LET', 'SignPainter',
    'Skia', 'Snell Roundhand', 'Times', 'Times New Roman', 'Trattatello',
    'Trebuchet MS', 'Verdana', 'Zapfino'
  ];
}

function getLinuxFonts() {
  return [
    'C059', 'Cantarell', 'D050000L', 'DejaVu Math TeX Gyre',
    'DejaVu Sans', 'DejaVu Sans Mono', 'DejaVu Serif', 'Droid Sans',
    'Droid Sans Mono', 'Droid Serif', 'Liberation Mono', 'Liberation Sans',
    'Liberation Sans Narrow', 'Liberation Serif', 'Nimbus Mono PS',
    'Nimbus Roman', 'Nimbus Sans', 'Nimbus Sans Narrow', 'Noto Color Emoji',
    'Noto Mono', 'Noto Sans', 'Noto Sans Mono', 'Noto Serif', 'P052',
    'Roboto', 'Standard Symbols PS', 'Ubuntu', 'Ubuntu Condensed',
    'Ubuntu Mono', 'URW Bookman', 'URW Gothic', 'Z003'
  ];
}

function getFontsForOS(osName) {
  switch (osName) {
    case 'windows': return getWindowsFonts();
    case 'macos': return getMacFonts();
    case 'linux': return getLinuxFonts();
    default: return getWindowsFonts();
  }
}

// Common screen resolutions with market share weighting
const SCREEN_PRESETS = [
  { w: 1920, h: 1080, weight: 40 },
  { w: 1366, h: 768,  weight: 15 },
  { w: 2560, h: 1440, weight: 12 },
  { w: 1536, h: 864,  weight: 8 },
  { w: 1440, h: 900,  weight: 6 },
  { w: 1680, h: 1050, weight: 5 },
  { w: 1280, h: 720,  weight: 4 },
  { w: 1600, h: 900,  weight: 4 },
  { w: 3840, h: 2160, weight: 3 },
  { w: 2560, h: 1600, weight: 3 },
];

function pickWeightedScreen() {
  const totalWeight = SCREEN_PRESETS.reduce((s, p) => s + p.weight, 0);
  let r = Math.random() * totalWeight;
  for (const p of SCREEN_PRESETS) {
    r -= p.weight;
    if (r <= 0) return { width: p.w, height: p.h };
  }
  return { width: 1920, height: 1080 };
}

// WebGL vendor/renderer pairs (realistic for Windows)
const WEBGL_PRESETS_WIN = [
  { vendor: 'Google Inc. (Intel)', renderer: 'ANGLE (Intel, Intel(R) UHD Graphics 630 Direct3D11 vs_5_0 ps_5_0, D3D11)' },
  { vendor: 'Google Inc. (Intel)', renderer: 'ANGLE (Intel, Intel(R) UHD Graphics 770 Direct3D11 vs_5_0 ps_5_0, D3D11)' },
  { vendor: 'Google Inc. (Intel)', renderer: 'ANGLE (Intel, Intel(R) Iris(R) Xe Graphics Direct3D11 vs_5_0 ps_5_0, D3D11)' },
  { vendor: 'Google Inc. (NVIDIA)', renderer: 'ANGLE (NVIDIA, NVIDIA GeForce GTX 1650 Direct3D11 vs_5_0 ps_5_0, D3D11)' },
  { vendor: 'Google Inc. (NVIDIA)', renderer: 'ANGLE (NVIDIA, NVIDIA GeForce RTX 3060 Direct3D11 vs_5_0 ps_5_0, D3D11)' },
  { vendor: 'Google Inc. (NVIDIA)', renderer: 'ANGLE (NVIDIA, NVIDIA GeForce RTX 4060 Direct3D11 vs_5_0 ps_5_0, D3D11)' },
  { vendor: 'Google Inc. (AMD)', renderer: 'ANGLE (AMD, AMD Radeon RX 580 Series Direct3D11 vs_5_0 ps_5_0, D3D11)' },
  { vendor: 'Google Inc. (AMD)', renderer: 'ANGLE (AMD, AMD Radeon(TM) Graphics Direct3D11 vs_5_0 ps_5_0, D3D11)' },
];

const WEBGL_PRESETS_MAC = [
  { vendor: 'Apple', renderer: 'Apple M1' },
  { vendor: 'Apple', renderer: 'Apple M2' },
  { vendor: 'Apple', renderer: 'Apple M3' },
  { vendor: 'Intel Inc.', renderer: 'Intel Iris Plus Graphics 640' },
  { vendor: 'Intel Inc.', renderer: 'Intel(R) UHD Graphics 630' },
];

function pickWebGL(osName) {
  const presets = osName === 'macos' ? WEBGL_PRESETS_MAC : WEBGL_PRESETS_WIN;
  return presets[Math.floor(Math.random() * presets.length)];
}

function generateFirefoxUA(osName) {
  const ffVersion = '135.0';
  const platforms = {
    windows: `Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:${ffVersion}) Gecko/20100101 Firefox/${ffVersion}`,
    macos: `Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:${ffVersion}) Gecko/20100101 Firefox/${ffVersion}`,
    linux: `Mozilla/5.0 (X11; Linux x86_64; rv:${ffVersion}) Gecko/20100101 Firefox/${ffVersion}`,
  };
  return platforms[osName] || platforms.windows;
}

function generateFingerprintConfig(payload) {
  const osName = (payload.os || 'windows').toLowerCase();
  const screen = payload.screen || pickWeightedScreen();
  const locale = payload.locale || 'en-US';
  const langBase = locale.split('-')[0];
  const ad = payload.antidetect || {};
  const webgl = pickWebGL(osName);

  // Taskbar offset for availHeight
  const taskbarHeight = osName === 'windows' ? 40 : (osName === 'macos' ? 25 : 30);
  const availHeight = screen.height - taskbarHeight;

  // Window dimensions (slightly smaller than screen)
  const outerWidth = screen.width;
  const outerHeight = availHeight;
  const innerWidth = outerWidth - 17; // scrollbar
  const innerHeight = outerHeight - 71; // toolbar + tabs

  const config = {
    // Navigator
    'navigator.userAgent': generateFirefoxUA(osName),
    'navigator.platform': osName === 'windows' ? 'Win32' : (osName === 'macos' ? 'MacIntel' : 'Linux x86_64'),
    'navigator.hardwareConcurrency': ad.hardwareConcurrency || [4, 6, 8, 12, 16][Math.floor(Math.random() * 5)],
    'navigator.language': locale,
    'navigator.languages': locale.startsWith('en')
      ? ['en-US', 'en']
      : [locale, langBase, 'en-US', 'en'],

    // Screen
    'screen.width': screen.width,
    'screen.height': screen.height,
    'screen.availWidth': screen.width,
    'screen.availHeight': availHeight,
    'screen.colorDepth': 24,
    'screen.pixelDepth': 24,
    'screen.outerWidth': outerWidth,
    'screen.outerHeight': outerHeight,
    'screen.innerWidth': innerWidth,
    'screen.innerHeight': innerHeight,

    // Window
    'window.screenX': 0,
    'window.screenY': 0,
    'window.history.length': Math.floor(Math.random() * 5) + 1,

    // Fonts
    'fonts': getFontsForOS(osName),
    'fonts:spacing_seed': Math.floor(Math.random() * 1073741824),

    // Canvas anti-fingerprinting
    'canvas:aaOffset': Math.floor(Math.random() * 101) - 50,
    'canvas:aaCapOffset': true,

    // Theme
    'disableTheming': true,
    'showcursor': false,
  };

  // WebGL
  if (ad.webgl?.noise !== false) {
    config['webgl:vendor'] = webgl.vendor;
    config['webgl:renderer'] = webgl.renderer;
  }

  return config;
}

// ─── Config → CAMOU_CONFIG_* env vars ────────────────────────────────
function configToEnvVars(config) {
  const json = JSON.stringify(config);
  const chunkSize = 2047; // Windows env var max size
  const envVars = {};
  for (let i = 0; i < json.length; i += chunkSize) {
    const chunk = json.substring(i, i + chunkSize);
    envVars[`CAMOU_CONFIG_${Math.floor(i / chunkSize) + 1}`] = chunk;
  }
  return envVars;
}

// ─── Write Firefox proxy prefs to profile user.js ─────────────────────
function writeProxyPrefs(profileDir, proxyHost, proxyPort, proxyType) {
  const userJsPath = path.join(profileDir, 'user.js');
  let existing = '';
  try { existing = fs.readFileSync(userJsPath, 'utf8'); } catch (e) {}
  // Remove old proxy lines
  existing = existing.split('\n')
    .filter(l => !l.includes('network.proxy.'))
    .join('\n');

  // proxyType: 1 = manual config
  const isSocks = proxyType === 'socks';
  let proxyPrefs;
  if (isSocks) {
    proxyPrefs = `
// === AEZAKMI Proxy Settings ===
user_pref("network.proxy.type", 1);
user_pref("network.proxy.socks", "${proxyHost}");
user_pref("network.proxy.socks_port", ${proxyPort});
user_pref("network.proxy.socks_version", 5);
user_pref("network.proxy.socks_remote_dns", true);
user_pref("network.proxy.no_proxies_on", "");
`;
  } else {
    proxyPrefs = `
// === AEZAKMI Proxy Settings ===
user_pref("network.proxy.type", 1);
user_pref("network.proxy.http", "${proxyHost}");
user_pref("network.proxy.http_port", ${proxyPort});
user_pref("network.proxy.ssl", "${proxyHost}");
user_pref("network.proxy.ssl_port", ${proxyPort});
user_pref("network.proxy.no_proxies_on", "");
user_pref("network.proxy.allow_hijacking_localhost", true);
`;
  }

  fs.writeFileSync(userJsPath, existing.trim() + '\n' + proxyPrefs);
  log('[CAMOUFOX] Прокси прописан в user.js:', `${proxyHost}:${proxyPort} (${isSocks ? 'socks5' : 'http'})`);
}

// ─── Clear proxy prefs from profile (when launching without proxy) ────
function clearProxyPrefs(profileDir) {
  const userJsPath = path.join(profileDir, 'user.js');
  let existing = '';
  try { existing = fs.readFileSync(userJsPath, 'utf8'); } catch (e) { return; }
  
  const cleaned = existing.split('\n')
    .filter(l => !l.includes('network.proxy.') && !l.includes('AEZAKMI Proxy Settings'))
    .join('\n');
  
  // Set proxy type to 0 (direct/no proxy)
  const noProxy = `\n// === AEZAKMI Proxy Settings ===\nuser_pref("network.proxy.type", 0);\n`;
  
  fs.writeFileSync(userJsPath, cleaned.trim() + noProxy);
  log('[CAMOUFOX] Прокси убран из user.js (direct connection)');
}

// ─── Write base Firefox prefs for privacy/security ────────────────────
function writeBasePrefs(profileDir, payload) {
  const userJsPath = path.join(profileDir, 'user.js');
  let existing = '';
  try { existing = fs.readFileSync(userJsPath, 'utf8'); } catch (e) {}

  // Remove old base prefs section
  existing = existing.replace(/\/\/ === AEZAKMI Base Prefs ===[\s\S]*?(?=\n\/\/ ===|\s*$)/, '');

  const ad = payload.antidetect || {};
  const basePrefs = [];

  // WebRTC protection
  if (ad.webrtc?.block !== false) {
    basePrefs.push('user_pref("media.peerconnection.enabled", false);');
  }

  // Timezone & locale
  if (payload.timezoneId) {
    basePrefs.push(`user_pref("intl.timezone.override", "${payload.timezoneId}");`);
  }
  if (payload.locale) {
    basePrefs.push(`user_pref("intl.accept_languages", "${payload.locale}");`);
  }

  // Disable telemetry & updates
  basePrefs.push(
    'user_pref("app.update.enabled", false);',
    'user_pref("datareporting.policy.dataSubmissionEnabled", false);',
    'user_pref("toolkit.telemetry.enabled", false);',
    'user_pref("browser.newtabpage.activity-stream.feeds.telemetry", false);',
    'user_pref("browser.ping-centre.telemetry", false);',
    // Don't show first run
    'user_pref("browser.startup.homepage_override.mstone", "ignore");',
    'user_pref("startup.homepage_welcome_url", "");',
    'user_pref("browser.shell.checkDefaultBrowser", false);',
    // Disable auto-import
    'user_pref("browser.migrate.automigrate.enabled", false);',
    // Ensure we can run without issues
    'user_pref("browser.tabs.warnOnClose", false);',
    'user_pref("browser.sessionstore.resume_from_crash", false);',
    // Allow unsigned extensions (needed for proxy helper extension)
    'user_pref("xpinstall.signatures.required", false);',
    'user_pref("extensions.autoDisableScopes", 0);',
    'user_pref("extensions.enabledScopes", 15);',
    // Don't show extension install prompts
    'user_pref("extensions.postDownloadThirdPartyPrompt", false);',
  );

  if (basePrefs.length > 0) {
    const block = '\n// === AEZAKMI Base Prefs ===\n' + basePrefs.join('\n') + '\n';
    fs.writeFileSync(userJsPath, existing.trim() + block);
  }
}

// ─── CAMOUFOX LAUNCH ──────────────────────────────────────────────────
async function launchCamoufox(payload) {
  log('[CAMOUFOX] ═══════════════════════════════════════');
  log('[CAMOUFOX] Запуск Camoufox (native antidetect)');
  logToFile('Launching Camoufox engine');

  // 1. Ensure binary installed
  await ensureCamoufoxInstalled();

  // Resolve actual exe path (might be in subfolder)
  let exe = getCamoufoxExe();
  if (!fs.existsSync(exe)) {
    const found = findExecutable(getCamoufoxDir(), 'camoufox.exe');
    if (found) {
      exe = found;
    } else {
      throw new Error(`camoufox.exe не найден в ${getCamoufoxDir()}`);
    }
  }

  // 2. Resolve profile dir
  let profileDir = payload.profileDir || `aezakmi-profile-${Date.now()}`;
  if (!path.isAbsolute(profileDir)) {
    const profilesBase = process.env.AEZAKMI_PROFILES_DIR
      || (process.env.LOCALAPPDATA
        ? path.join(process.env.LOCALAPPDATA, 'AEZAKMI Pro', 'profiles')
        : path.join(appDir, 'profiles'));
    profileDir = path.join(profilesBase, profileDir);
  }
  fs.mkdirSync(profileDir, { recursive: true });
  log('[CAMOUFOX] Профиль:', profileDir);

  // 3. Generate fingerprint config
  const fpConfig = generateFingerprintConfig(payload);
  const camoufoxEnv = configToEnvVars(fpConfig);
  log('[CAMOUFOX] Fingerprint:', JSON.stringify({
    ua: fpConfig['navigator.userAgent'].substring(0, 60) + '...',
    screen: `${fpConfig['screen.width']}x${fpConfig['screen.height']}`,
    locale: fpConfig['navigator.language'],
    webgl: fpConfig['webgl:renderer'] ? fpConfig['webgl:renderer'].substring(0, 40) : 'default',
  }));

  // 4. Setup proxy — use Firefox extension for auth, user.js prefs otherwise
  //    NOTE: camoufox.exe spawns the real browser and exits immediately (~275ms),
  //    so we CANNOT use external bridges — they die before the browser loads.
  //    Instead, we install a WebExtension that handles proxy routing + auth inside the browser.
  if (payload.proxy && payload.proxy.server) {
    const { server, username, password } = payload.proxy;
    const hasAuth = !!(username && password);
    
    // Parse proxy URL
    let proxyServer = server;
    if (!proxyServer.includes('://')) proxyServer = 'http://' + proxyServer;
    
    let proxyUrl;
    try {
      proxyUrl = new URL(proxyServer);
    } catch (e) {
      warn('[CAMOUFOX] Некорректный формат прокси:', server);
      proxyUrl = null;
    }

    if (proxyUrl) {
      const protocol = proxyUrl.protocol.replace(':', '').toLowerCase(); // http, https, socks4, socks5
      const pHost = proxyUrl.hostname;
      const pPort = parseInt(proxyUrl.port) || (protocol.includes('socks') ? 1080 : 8080);
      const isSocks = protocol.includes('socks');

      log('[CAMOUFOX] Прокси:', `${protocol}://${pHost}:${pPort}`, hasAuth ? '(с auth)' : '(без auth)');
      logToFile(`Proxy: ${protocol}://${pHost}:${pPort} auth=${hasAuth}`);

      if (hasAuth) {
        // Auth required → Firefox extension handles proxy + credentials
        // Works for ALL types: http, https, socks4, socks5
        setupProxyExtension(profileDir, {
          type: protocol,
          host: pHost,
          port: pPort,
          username: username,
          password: password,
        });
        // Set proxy.type=0 in user.js — extension overrides per-request via proxy.onRequest
        clearProxyPrefs(profileDir);
        log('[CAMOUFOX] Прокси через расширение (с авторизацией)');
      } else if (isSocks) {
        // SOCKS without auth — native Firefox prefs
        removeProxyExtension(profileDir);
        writeProxyPrefs(profileDir, pHost, pPort, 'socks');
      } else {
        // HTTP/HTTPS without auth — native Firefox prefs
        removeProxyExtension(profileDir);
        writeProxyPrefs(profileDir, pHost, pPort, 'http');
      }
    }
  } else {
    // No proxy — clean up extension and prefs
    removeProxyExtension(profileDir);
    clearProxyPrefs(profileDir);
  }

  // 5. Write base prefs (timezone, locale, WebRTC, etc.)
  writeBasePrefs(profileDir, payload);

  // 6. Build launch args
  const args = ['-profile', profileDir, '-no-remote'];

  // Add URL if provided
  const url = payload.url || 'https://www.google.com';
  args.push('-new-tab', url);

  log('[CAMOUFOX] Exe:', exe);
  log('[CAMOUFOX] Args:', args.join(' '));
  log('[CAMOUFOX] CAMOU_CONFIG chunks:', Object.keys(camoufoxEnv).length);

  // 7. Spawn Camoufox process
  const child = spawn(exe, args, {
    env: { ...process.env, ...camoufoxEnv },
    stdio: isDev ? ['ignore', 'pipe', 'pipe'] : 'ignore',
    detached: false,
    windowsHide: false,
  });

  if (isDev && child.stdout) {
    child.stdout.on('data', (d) => log('[CAMOUFOX-OUT]', d.toString().trim()));
  }
  if (isDev && child.stderr) {
    child.stderr.on('data', (d) => log('[CAMOUFOX-ERR]', d.toString().trim()));
  }

  log('[CAMOUFOX] PID:', child.pid);
  logToFile(`Camoufox launched, PID: ${child.pid}`);

  // 8. Wait for process exit
  await new Promise((resolve) => {
    child.on('exit', (code) => {
      log('[CAMOUFOX] Процесс завершён, код:', code);
      logToFile(`Camoufox exited, code: ${code}`);
      resolve();
    });
    child.on('error', (err) => {
      error('[CAMOUFOX] Ошибка процесса:', err.message);
      logToFile(`Camoufox error: ${err.message}`);
      resolve();
    });
  });

  // 9. Done — no bridge cleanup needed (extension handles proxy inside browser)
}

// ═══════════════════════════════════════════════════════════════════════
// MAIN ENTRY POINT
// ═══════════════════════════════════════════════════════════════════════
async function main() {
  try {
    const argv = process.argv.slice(2);
    if (argv.includes('--help') || argv.includes('-h')) {
      log('AEZAKMI Launcher v4.0.0 (Camoufox antidetect)');
      log('Usage: node launch_playwright.cjs --payload=<base64-json>');
      process.exit(0);
    }
    if (argv.includes('--dry-run')) {
      log('Dry-run OK');
      process.exit(0);
    }

    // Parse payload
    const payloadArg = argv.find(a => a.startsWith('--payload='));
    const payloadB64 = payloadArg ? payloadArg.replace('--payload=', '') : argv[0];
    if (!payloadB64) throw new Error('Missing payload argument');

    const json = Buffer.from(payloadB64, 'base64').toString('utf8');
    const payload = JSON.parse(json);

    log('[LAUNCHER] ═══════════════════════════════════════');
    log('[LAUNCHER] Профиль:', payload.profileDir);
    log('[LAUNCHER] Движок: Camoufox (antidetect Firefox)');
    log('[LAUNCHER] Прокси:', payload.proxy?.server || 'нет');
    log('[LAUNCHER] Язык:', payload.locale || 'не указан');
    log('[LAUNCHER] ═══════════════════════════════════════');

    await launchCamoufox(payload);

  } catch (err) {
    error('[LAUNCHER] Ошибка:', err.message);
    logToFile(`ERROR: ${err.message}\n${err.stack}`);
    process.exit(1);
  }
}

main();
